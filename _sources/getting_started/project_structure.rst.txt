From Single File to Project Structure
======================================

This page shows how a working **single-file example**
is typically organized into a minimal but **realistic**
project structure when using SimpleAppState.

This page is written for new team members and assumes that:

- you have already run a working example
- all application state is defined in one place
- UI code depends on state, not the other way around


Project structure
-----------------

In SimpleAppState-based projects, application state is usually
collected into a single file.

Placing this file at a higher-level directory makes the
state definition easy to find and reason about.

A recommended minimal structure is:

.. code-block:: text

   lib/
   ├── ui/
   │   ├── app_state.dart
   │   └── pages/
   │       └── counter_view.dart
   └── main.dart

- ``ui/app_state.dart`` defines *all application state*
- UI pages live under ``ui/pages/``
- Widgets import state, but state never imports widgets

This structure keeps responsibilities clear
and prevents accidental coupling between UI and state.


Define application state (``ui/app_state.dart``)
------------------------------------------------

First, create a global ``SimpleAppState`` instance.
In most applications, this object lives for the entire
lifetime of the app.

.. code-block:: dart

   // ui/app_state.dart
   final appState = SimpleAppState();

Next, define all state slots in the same file.
This makes the complete state surface visible at a glance.

.. code-block:: dart

   // Counter value (int)
   final count = appState.slot<int>('count', initial: 0);

Key points:

- All application state is defined in one file
- Slot types are fixed on first access
- Slot names must be unique within the same state
- Complex state can be composed using serializable classes,
  lists, and maps


What does *not* belong in SimpleAppState
-----------------------------------------

SimpleAppState is intended to hold **application state** —
data that is meaningful beyond a single widget’s lifetime.

Temporary, non-serializable, or UI-only values
(such as animation controllers, focus state, or local flags)
should live inside Flutter widgets instead.

This clear separation keeps application state:

- predictable
- easy to reason about
- safe for persistence and undo / redo

If some data feels awkward to store in SimpleAppState,
it is often a sign that the data belongs to a widget,
not to the app state.


Update state
------------

State can be updated using ``set`` or ``update``.

.. code-block:: dart

   count.set(1);

``update`` is useful when the new value depends
on the previous value.

.. code-block:: dart

   count.update((old) => old + 1);

State updates are applied immediately.
Subscribed widgets will rebuild automatically.


Bind state to a widget (``ui/pages/counter_view.dart``)
---------------------------------------------------------

Widgets import state slots and declare which ones they depend on.

.. code-block:: dart

   // ui/pages/counter_view.dart

   class CounterView extends SlotStatefulWidget {
     const CounterView({super.key});

     @override
     List<StateSlot> get slots => [count];

     @override
     State<CounterView> createState() => _CounterViewState();
   }

   class _CounterViewState extends SlotState<CounterView> {
     @override
     Widget build(BuildContext context) {
       final value = count.get();

       return Column(
         children: [
           Text('Count: $value'),
           ElevatedButton(
             onPressed: () {
               count.update((v) => v + 1);
             },
             child: const Text('Increment'),
           ),
         ],
       );
     }
   }

Key ideas:

- Widgets do not own application state
- Widgets explicitly declare slot dependencies
- Rebuilds are deterministic and minimal


Builder-based subscription (optional)
--------------------------------------

In addition to subclassing ``SlotStatefulWidget``,
SimpleAppState provides a builder-style widget
called ``StateSlotBuilder``.

This is a small convenience API for cases where:

- you want to subscribe to slots without creating a widget subclass
- the UI fragment is simple or read-only
- you prefer a more local, inline definition

The behavior is the same as ``SlotStatefulWidget``:
widgets rebuild deterministically when the subscribed
slots change.

.. code-block:: dart

   StateSlotBuilder(
     slotList: [count],
     builder: (context) {
       return Text('Count: ${count.get()}');
     },
   );

This form does not introduce any additional magic.
It is simply another way to declare slot dependencies.


Why this structure is recommended
---------------------------------

This layout enforces a clear separation of responsibilities:

- ``app_state.dart`` defines *what* the application state is
- UI widgets define *how* the state is presented and modified

With this structure, developers can always answer:

- "Where is this state defined?"
- "Which widgets depend on it?"

without searching through widget trees or implicit contexts.


Next step
---------

You now know how a working example
is typically organized in real applications.

At this point, you have already seen
a complete example once.

Before moving on to larger topics,
let’s look at the same example again —
this time more carefully,
with a deeper explanation of
*why it is structured this way*.

For reference and experimentation,
see the complete single-file version again:

- :doc:`single_file_example`

In the next sections, we will break this example apart
and explain each responsibility in detail.

