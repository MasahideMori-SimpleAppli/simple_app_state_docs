Single-file example
===================

This page shows a **complete, copy-and-run example**
of a Flutter application using **SimpleAppState**.

All application state, UI, and setup code are contained
in a single file so that you can experiment freely and
understand the full data flow at once.

You can paste this file directly into a Flutter project
(e.g. `lib/main.dart`) and run it.

Complete example
----------------

.. code-block:: dart

    import 'package:flutter/foundation.dart';
    import 'package:flutter/material.dart';
    import 'package:simple_app_state/simple_app_state.dart';

    ///////////////////////////////////////////////////////////////////////////////
    ///
    /// Application State Definition (This is usually written in lib/ui/app_state.dart.)
    ///
    /// - Widgets do NOT own application state.
    /// - StateSlots are defined once and reused everywhere.
    ///
    ///////////////////////////////////////////////////////////////////////////////

    /// A state container shared across the app
    final appState = SimpleAppState();

    /// counter value（`int`）
    final countSlot = appState.slot<int>('count', initial: 0);

    /// log（`List<String>`）
    final logsSlot = appState.slot<List<String>>(
      'logs',
      initial: [],
      caster: (raw) => raw != null ? (raw as List).cast<String>() : null,
    );

    void main() {
      /// You can easily define a debugger to use only during development.
      if (kDebugMode) {
        appState.setDebugListener((slot, oldV, newV) {
          /// You can also use slot.name here to print only in a specific slot.
          debugPrint(
            "Changed Slot:${slot.name}, Value changed from:$oldV, to:$newV",
          );
        });
      }
      runApp(const MyApp());
    }

    ///////////////////////////////////////////////////////////////////////////////
    ///
    /// Flutter Application
    ///
    ///////////////////////////////////////////////////////////////////////////////

    class MyApp extends StatelessWidget {
      const MyApp({super.key});

      @override
      Widget build(BuildContext context) {
        return const MaterialApp(home: CounterPage());
      }
    }

    ///////////////////////////////////////////////////////////////////////////////
    ///
    /// UI Layer
    ///
    /// Widgets subscribe to StateSlots.
    /// They never store application state themselves.
    ///
    ///////////////////////////////////////////////////////////////////////////////

    class CounterPage extends StatelessWidget {
      const CounterPage({super.key});

      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(title: const Text('SimpleAppState Example')),
          body: Column(
            children: [
              const SizedBox(height: 32),

              /// Minimal example of a single slot dependency
              StateSlotBuilder(
                slotList: [countSlot],
                builder: (context) {
                  final count = countSlot.get();
                  return Text(
                    'Count: $count',
                    style: Theme.of(context).textTheme.headlineMedium,
                  );
                },
              ),
              const SizedBox(height: 24),

              /// Batch multiple slot updates
              ElevatedButton(
                onPressed: () {
                  appState.batch(() {
                    countSlot.update((v) => (v ?? 0) + 1);

                    logsSlot.update((list) {
                      final next = List<String>.from(list ?? const []);
                      next.add('Increment at ${DateTime.now()}');
                      return next;
                    });
                  });
                },
                child: const Text('Increment (batched)'),
              ),
              const Divider(height: 32),

              /// Read-only UI based on deep copy
              Expanded(
                child: StateSlotBuilder(
                  slotList: [logsSlot],
                  builder: (context) {
                    final items = logsSlot.get() ?? [];
                    return ListView.builder(
                      itemCount: items.length,
                      itemBuilder: (context, index) {
                        return ListTile(title: Text(items[index]));
                      },
                    );
                  },
                ),
              ),
            ],
          ),
        );
      }
    }

How to read this example
-------------------------

Although everything is written in one file,
the code can be read in three logical sections:

1. **Application state**
   - A single `SimpleAppState` instance
   - All `StateSlot` definitions in one place

2. **Application entry point**
   - `main()` initializes debugging hooks
   - No application logic is embedded here

3. **UI layer**
   - Widgets subscribe explicitly to slots
   - No widget stores application state

In real applications, these sections are usually
split into separate files without changing the model.

State definition
----------------

All application state is defined once and reused everywhere.

Each `StateSlot`:

- has a fixed type
- is identified by a unique name
- represents a single unit of observable state

This makes the complete state surface easy to find
and reason about.

Slot subscription
-----------------

Widgets subscribe to state using `StateSlotBuilder`,
a builder-style convenience widget.

.. code-block:: dart

   StateSlotBuilder(
     slotList: [countSlot],
     builder: (context) {
       return Text('Count: ${countSlot.get()}');
     },
   );

This form does not introduce additional behavior.
It is simply a concise way to declare slot dependencies.

Batch updates
-------------

Multiple slot updates can be grouped using `batch`.

- All updates inside the batch are applied synchronously
- Each subscribed widget is notified only once.

This is useful when multiple state values represent
a single logical change.

Debugging and testing
---------------------

This example attaches a debug listener during development
to observe all state changes.

Debug listeners are optional and are not required
for normal application logic.

Detailed explanations and testing patterns using
debug listeners are covered in the
:doc:`../advanced/testing` section.

Key takeaways
-------------

This example demonstrates typical SimpleAppState usage:

- application state is defined in one place
- widgets declare explicit slot dependencies
- rebuilds are deterministic and predictable
- debugging hooks do not affect application logic

Once this structure is understood, it scales naturally
to larger applications by splitting files,
not by changing concepts.

Next step
---------------------------------
Next, let’s look at some common beginner mistakes.

Once you understand these patterns, you’ll be able to use
SimpleAppState more confidently in your own projects.

Go to :doc:`common_mistakes` section.