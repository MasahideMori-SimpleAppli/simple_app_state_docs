Common Mistakes
===============

This section lists common mistakes made by new users of SimpleAppState.
Each mistake is explained together with the correct mental model.

Treating state as widget-owned
------------------------------

**Mistake**

Defining ``SimpleAppState`` or slots inside widgets:

.. code-block:: dart

   class MyWidget extends StatelessWidget {
     final appState = SimpleAppState(); // ❌
   }

**Why this is a problem**

Widgets in Flutter are ephemeral.
They can be rebuilt, recreated, or disposed at any time.

Placing application state inside widgets makes state lifetime
hard to reason about and breaks persistence and undo/redo use cases.

**Correct approach**

Define application state at a higher level,
typically as a global or top-level object:

.. code-block:: dart

   final appState = SimpleAppState();
   final count = appState.slot<int>('count', initial: 0);

Widgets should *subscribe* to state, not own it.

Mutating values returned from slots
-------------------------------------

**Mistake**

Assuming that modifying a value returned from ``get()``
will update application state:

.. code-block:: dart

   final list = logs.get();
   list.add('new entry'); // ❌ has no effect

**Why this is a problem**

Values returned from ``StateSlot.get()`` are always deep-copied.
This is intentional and enforces value semantics.

This is very important because manipulating object references like this in the normal way usually results in other parts breaking or spaghetti code.

This package forces this to not happen.
Direct mutation never affects internal state.

For the same reason, SimpleAppState intentionally does not provide
an "unsafe" API for storing non-copyable or non-serializable objects.

Temporary or UI-specific state (such as controllers, animation state,
or ephemeral flags) should live inside widgets, not in application state.

This clear boundary prevents hidden coupling and keeps state evolution
easy to reason about.

**Correct approach**

Always use ``set`` or ``update``:

.. code-block:: dart

    logs.update((old) {
      final next = List<String>.from(old);
      next.add('new entry');
      return next;
    });

Forgetting to declare slot dependencies
---------------------------------------

**Mistake**

Accessing slot values in a widget without declaring them
in ``slots``:

.. code-block:: dart

   class CounterView extends SlotStatefulWidget {
     @override
     List<StateSlot> get slots => []; // ❌
   }

**Why this is a problem**

SimpleAppState does not use implicit dependency tracking.
If a widget does not declare a slot, it will not rebuild
when that slot changes.

**Correct approach**

Explicitly list all slots the widget depends on:

.. code-block:: dart

   @override
   List<StateSlot> get slots => [count];

Creating many small state objects
---------------------------------

**Mistake**

Creating multiple ``SimpleAppState`` instances
for logically related application state.

**Why this is a problem**

Splitting state ownership too early makes it difficult
to perform coordinated updates and persistence.

**Correct approach**

Start with a single ``SimpleAppState`` instance.
Introduce multiple state objects only when you have
clear ownership boundaries.

Expecting context-based lookups
-------------------------------

**Mistake**

Assuming that widgets can implicitly access application state.

**Why this is a problem**

SimpleAppState intentionally avoids implicit or context-based state access.
All state dependencies must be explicit and visible in code.

This keeps rebuild behavior predictable and makes it clear
which state changes can affect a given widget.

**Correct approach**

Pass or import the required ``StateSlot`` explicitly.
If a widget rebuilds, you should always be able to point
to the exact slot that caused it.

Updating state during build
---------------------------

**Mistake**

Updating application state during widget build:

.. code-block:: dart

   @override
   Widget build(BuildContext context) {
     countSlot.update((v) => v + 1); // ❌
     return const Text('Hello');
   }

**Why this is a problem**

Widget build methods must be pure.
They may run many times, and changing state during build
can cause repeated rebuilds or unstable behavior.

**Correct approach**

Only update state in response to events
(such as user actions or lifecycle callbacks).

For a detailed explanation, see:
:doc:`../flutter_integration/common_mistakes`

Next step
---------------------------------
Congratulations! You’ve mastered the basics of **SimpleAppState**.

From here, you can explore more advanced topics depending
on your interests:

- :doc:`../core_concepts/index`
- :doc:`../flutter_integration/index`
- :doc:`../advanced/index`

Happy development!
