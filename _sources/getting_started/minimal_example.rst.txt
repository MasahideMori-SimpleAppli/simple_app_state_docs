Minimal Example
===============

This page shows a minimal but **realistic** project structure
for Flutter applications using SimpleAppState.

This example is written for new team members and assumes:

- all application state is defined in one place
- UI code depends on state, not the other way around

Project structure
-----------------

In SimpleAppState-based projects, application state is usually
collected into a single file.

Placing this file at a higher-level directory makes the
state definition easy to find and reason about.

A recommended minimal structure is:

.. code-block:: text

   lib/
   ├── ui/
   │   ├── app_state.dart
   │   └── pages/
   │       └── counter_view.dart
   └── main.dart

- ``ui/app_state.dart`` defines *all application state*
- UI pages live under ``ui/pages/``
- Widgets import state, but state never imports widgets

Define application state (``ui/app_state.dart``)
--------------------------------------------------

First, create a global ``SimpleAppState`` instance.
In most applications, this object lives for the entire
lifetime of the app.

.. code-block:: dart

   // ui/app_state.dart
   final appState = SimpleAppState();

Next, define all state slots in the same file.
This makes the complete state surface visible at a glance.

.. code-block:: dart

   // Counter value (int)
   final count = appState.slot<int>('count', initial: 0);

- All application state is defined in one file
- Slot types are fixed on first access
- Slot names must be unique within the same state
- Complex state or data classes can be configured as serializable classes (extends CloneableFile), lists, maps, etc.

Update state
------------

State can be updated using ``set`` or ``update``.

.. code-block:: dart

   count.set(1);

``update`` is useful when the new value depends
on the previous value.

.. code-block:: dart

   count.update((old) => (old ?? 0) + 1);

State updates are applied immediately.
Subscribed widgets will rebuild automatically.


Bind state to a widget (``ui/pages/counter_view.dart``)
---------------------------------------------------------

Widgets import state slots and declare which ones they depend on.

.. code-block:: dart

   // ui/pages/counter_view.dart

   class CounterView extends SlotStatefulWidget {
     const CounterView({super.key});

     @override
     List<StateSlot> get slots => [count];

     @override
     State<CounterView> createState() => _CounterViewState();
   }

   class _CounterViewState extends SlotState<CounterView> {
     @override
     Widget build(BuildContext context) {
       final value = count.get() ?? 0;

       return Column(
         children: [
           Text('Count: $value'),
           ElevatedButton(
             onPressed: () {
               count.update((v) => (v ?? 0) + 1);
             },
             child: const Text('Increment'),
           ),
         ],
       );
     }
   }

- Widgets do not own application state
- Widgets explicitly declare slot dependencies
- Rebuilds are deterministic and minimal

Builder-based subscription (optional)
-------------------------------------

In addition to subclassing `SlotStatefulWidget`,
SimpleAppState provides a builder-style widget
called `StateSlotBuilder`.

This is a small convenience API for cases where:

- you want to subscribe to slots without creating a widget subclass
- the UI fragment is simple or read-only
- you prefer a more local, inline definition

The behavior is the same as `SlotStatefulWidget`:
widgets rebuild deterministically when the subscribed
slots change.

.. code-block:: dart

   StateSlotBuilder(
     slotList: [count],
     builder: (context) {
       return Text('Count: ${count.get()}');
     },
   );

This form does not introduce any additional magic.
It is simply a different way to declare slot dependencies.


Why this structure is recommended
---------------------------------

This layout enforces a clear separation of responsibilities:

- ``app_state.dart`` defines *what* the application state is
- UI widgets define *how* the state is presented and modified

New developers can always answer:

- "Where is this state defined?"
- "Which widgets depend on it?"

without searching through widget trees or contexts.

Next step
---------------------------------
Now let’s take what we’ve learned and look at a complete,
working example.

Go to :doc:`single_file_example` section.